# -*- coding: utf-8 -*-
"""User based movie recommendation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16ed1NE1rGAfC_X3JpLf8ItrlDeu_KqSv
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math
import string
import nltk
from nltk.stem.snowball import SnowballStemmer
from ast import literal_eval
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import QuantileTransformer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.model_selection import train_test_split
pd.set_option('display.max.columns', None)

metadata = pd.read_csv('/content/drive/MyDrive/Dataset/data/movies_metadata_small.csv')
keywords = pd.read_csv('/content/drive/MyDrive/Dataset/data/keywords_small.csv')
credits = pd.read_csv('/content/drive/MyDrive/Dataset/data/credits_small.csv')
links = pd.read_csv('/content/drive/MyDrive/Dataset/data/links_small.csv')
ratings = pd.read_csv('/content/drive/MyDrive/Dataset/data/ratings_small.csv')

metadata.isnull().sum()

metadata.fillna("",inplace=True)
metadata.shape

def get_genres(genres):
    return ' '.join([i['name'] for i in genres])
def get_cast(cast):
    if len(cast)>7:
        cast=cast[:7];
    return [people['name'].translate(str.maketrans('','', " -.'")) for people in cast]
def get_director(crew):
    for person in crew:
        if person['job']=='Director':
            return [person['name'].translate(str.maketrans('','', " -.'"))]
    return []
def get_people(x):
    people = x['cast'] if x['genres'].find('Animation')==-1 else x['cast'][0:3]
    for d in x['director']:
        if d not in people:
            people.append(d)
    return ' '.join(people)
def get_keywords(keywords):
    return ' '.join([i['name'] for i in keywords])

metadata['genres']= metadata['genres'].apply(literal_eval).apply(get_genres)
credits['cast'] = credits['cast'].apply(literal_eval).apply(get_cast)
credits['director'] = credits['crew'].apply(literal_eval).apply(get_director)
keywords['keywords'] = keywords['keywords'].apply(literal_eval).apply(get_keywords)

info = pd.merge(credits[['id', 'cast', 'director']], keywords, how='inner', on='id')
metadata = pd.merge(metadata, info, how='inner', on='id')
metadata['keys']=metadata.apply(lambda x : x['title']+" "+x['overview']+" "+x['tagline']+" "+x['keywords'],axis=1)
metadata['people'] = metadata.apply(get_people, axis=1)
metadata = metadata[['id','title','people','genres','keys','popularity','release_date','vote_average']].copy()
metadata.head(2)

stemmer = SnowballStemmer(language='english')
nltk.download('stopwords')
stopwords = nltk.corpus.stopwords.words('english')
def get_keys(x):
    x = x.translate(str.maketrans('', '', string.punctuation))
    return ' '.join([stemmer.stem(w) for w in x.split() if stemmer.stem(w) not in stopwords])
metadata['keys'] = metadata['keys'].apply(get_keys)

transformer = QuantileTransformer(output_distribution='uniform')
metadata['popularity'] = pd.Series(transformer.fit_transform(metadata[['popularity']]).reshape(-1))
metadata['release_date'] = pd.Series(transformer.fit_transform(metadata[['release_date']]).reshape(-1))
metadata['vote_average'] = metadata['vote_average'].apply(lambda x : np.nan if x==0 else x)
mean_average = metadata['vote_average'].mean()
metadata.fillna(mean_average, inplace=True)
metadata['vote_average'] = (metadata['vote_average']/10)
metadata.head(2)

movies = pd.concat([pd.Series(metadata.index, name='index'), metadata[['id','title']]],axis=1)
obj_cast = CountVectorizer(lowercase=True, analyzer='word', min_df=5)
cast_val = obj_cast.fit_transform(metadata['people']).toarray()
obj_genre = TfidfVectorizer()
genre_val = np.minimum(0.5, obj_genre.fit_transform(metadata['genres']).toarray())*2
obj_tfidf = TfidfVectorizer(min_df=50)
tfidf_val = np.minimum(0.25, obj_tfidf.fit_transform(metadata['keys']).toarray())*6
features_col = list(obj_cast.get_feature_names_out()) + list(obj_genre.get_feature_names_out()) + list(obj_tfidf.get_feature_names_out())
features = np.concatenate((cast_val, genre_val, tfidf_val), axis=1)
movies.shape, cast_val.shape, genre_val.shape, tfidf_val.shape, features.shape

ratings = pd.merge(ratings, links, how='inner', on='movieId')
ratings = ratings.loc[:,['userId', 'tmdbId', 'rating']]

userId = 1
user_data = ratings.loc[ratings['userId']==userId]
user_data = pd.merge(movies, user_data, how='inner', left_on='id', right_on='tmdbId')
user_data['rating'] = (user_data['rating']-3)/2
user_data[['index','id','title','rating']].head()

x_train, x_test = train_test_split(user_data, test_size=0.2, random_state= 100)
x = features[x_train['index'].values]
y = x_train[['rating']].values
usermul = np.matmul(np.transpose(y), x).reshape(-1)
feature_sum = np.sum(x, axis=0)
feature_cnt = np.sum(x>0, axis=0)
u1 = np.divide(usermul, feature_sum, out=np.zeros(usermul.shape), where = feature_sum!=0)
u2 = np.log(1+feature_cnt)
temp = np.concatenate((np.zeros(cast_val.shape[1],dtype=bool), np.ones(genre_val.shape[1]+tfidf_val.shape[1],dtype=bool)))
np.log(1+u2, out = u2, where = temp)
np.sqrt(u2, out = u2, where = (~temp))
user_profile = u1*u2
matmul = np.dot(features, user_profile)
mv_sum = np.sum(features, axis=1)
pred_rating = np.divide(matmul, mv_sum, out = np.zeros(matmul.shape), where = mv_sum!=0)
pred = pd.concat([movies, pd.Series(pred_rating, name='pred_rating')],axis=1)
pred.loc[x_train['index'].values, 'rating'] = x_train['rating'].values
pred.loc[x_train['index'].values, 'watched'] = 1
pred[['rating', 'pred_rating']].groupby('rating').mean().reset_index()

user_profile[0:3046].max(), user_profile[3046:3068].max(), user_profile[3068:].max()

u2[0:3046].max(), u2[3046:3068].max(), u2[3068:].max()

user_features = sorted(list(enumerate(user_profile)), key=lambda x : x[1], reverse=True)
[(i[0],features_col[i[0]],i[1]) for i in user_features[0:40]]

pred.iloc[1993,:]

pred.loc[x_test['index'].values, 'rating'] = x_test['rating'].values
unwatched = pred.loc[np.isnan(pred['watched']),:]
unwatched.sort_values('pred_rating', ascending = False).head(100)

def why_this_movie(user_profile, movie_index):
    temp = user_profile*features[movie_index,:]
    temp = sorted(list(enumerate(temp)), key=lambda x : x[1], reverse=True)
    return [(i[0],features_col[i[0]],i[1]) for i in temp[0:10]]

why_this_movie(user_profile, 8818)

features[8818,3046], user_profile[3046]



metadata.iloc[8818,:]

user_profile.shape

().shape